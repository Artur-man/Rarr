---
title: "Reading Zarr arrays with Rarr"
date: "`r BiocStyle::doc_date()`"
author:
- name: Mike L. Smith
  affiliation:  
  - EMBL Heidelberg
  email: mike.smith@embl.de
package: "`r BiocStyle::pkg_ver('Rarr')`"
vignette: >
  %\VignetteIndexEntry{"Working with Zarr arrays with Rarr"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

**Rarr** is intended to be a simple interface to reading (and eventually writing) individual Zarr arrays.  

It is developed in R and C with no reliance on external libraries or APIs for interfacing with the Zarr arrays.
Additional compression libraries (e.g. blosc) are bundled with **Rarr** to provide support for datasets compressed
using these tools.

**Rarr** is not designed to be aware of hierarchical Zarr array stores, but the component arrays can be read individually
by providing the path to them directly.

# Basic usage

```{r, load_library}
library(Rarr)
```

Rpackage("Rarr") can be used to read files either on local disk or on remote S3 storage systems.  First lets take a look at reading from a local file.

## Reading a from a local Zarr array

The are some example Zarr arrays in the package.  These were created using the Zarr Python implementation.  You can use the code below to list the complete set on your system, however it's a long list so we don't show the output here.

```{r, local-examples, echo = TRUE, results = "hide"}
list.dirs(system.file("extdata", "zarr_examples", package = "Rarr"), 
          recursive = TRUE) |> 
  grep(pattern = "zarr$", value = TRUE)
```

We'll pick the example file containing 32-bit integers arrange in the "column first" ordering.

```{r, use-example}
zarr_example <- system.file("extdata", "zarr_examples", "column-first", "int32.zarr",
                      package = "Rarr")
```

### Exploring the data

We can get an summary of the array properties, such as its shape and datatype, using the function `zarr_overview()`.  We can see in the output that follows that the data type (`int32`) corresponds to what we expect.

```{r, overview-1}
zarr_overview(zarr_example)
```

The `zarr_overview()` function also has the argument `as_data_frame` which toggles whether to print the output to screen, as shown above, or to return a `data.frame` containing the array details.  This latter option is useful if you want to compute on the array metadata later.

```{r, overview-2}
zarr_overview(zarr_example, as_data_frame = TRUE)
```

### Reading from an array

The summary information retrieved above is required, as to read the array with **Rarr** you need to know the shape and size of the array (unless you want to read the entire array).  From the previous output we can see our example array has three dimensions of size 30 x 20 x 10.  We can select the subset we want to extract using a `list`.
The list must have the same length as the number of dimensions in our array, with each element of the list corresponding to the indices you want to extract in that dimension.

```{r}
index <- list(1:4, 1:2, 1)
```

We then extract the subset using `read_zarr_array()`:

```{r, extract-subset}
read_zarr_array(zarr_example, index = index)
```


## Reading from S3 storage


```{r, read-from-s3}
s3_address = "https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0076A/10501752.zarr/0"
zarr_overview( s3_address )
```

The output above indicates that the array is stored in 50 chunks, each containing a slice of the overall data.  
In the example below we use the `index` argument to extract the first and tenth slices from the array.
We then plot these on top of one another using the `image()` function.  Choosing to read only 2 of the 50 slices is much faster than if we opted to download the entire array before accessing the data.

```{r, plot-raster, echo = 2:4, cache = TRUE, out.width="30%"}
par(mar = c(0,0,0,0))
z2 <- read_zarr_array(s3_address, index = list(c(1,10), NULL, NULL))
## plot the first slice in blue
image(log2(z2[1,,]), col = hsv(h = 0.6, v = 1, s = 1, alpha = 0:100/100), 
      asp = dim(z2)[2] / dim(z2)[3], axes = FALSE)
## overlay the tenth slice in green
image(log2(z2[2,,]), col = hsv(h = 0.3, v = 1, s = 1, alpha = 0:100/100), 
      asp = dim(z2)[2] / dim(z2)[3], axes = FALSE, add = TRUE)
```

### Using credentials to access private S3 buckets

If you're accessing data in a private S3 bucket, you can set the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` to store your credentials.  For example, lets try reading a file in a private S3 bucket:

```{r, s3-forbidden,  error=TRUE}
zarr_overview("https://s3.embl.de/rarr-testing/bzip2.zarr")
```

We can see the "Access Denied" message in our output, indicating that we don't have persmissions to access this resource.  However, if we use the key pair below, which give read-only access to the objects in the `r`arr-testing` bucket, we're now able to interogate the files with functions in *Rarr*.

```{r}
Sys.setenv("AWS_ACCESS_KEY_ID" = "V352gmotks4ZyhfU",
           "AWS_SECRET_ACCESS_KEY" = "2jveausI91c8P3c7OCRIOrxdLbp3LNW8")
zarr_overview("https://s3.embl.de/rarr-testing/bzip2.zarr")
```

## Writing to a Zarr array

```{r, example-array}
x <- array(1:600, dim = c(10,10,6))
```

```{r}
path_to_new_zarr <- file.path(tempdir(), "new.zarr")
write_zarr_array(x = x, zarr_array_path = path_to_new_zarr, chunk_dim = c(10,5,1))
```

```{r, check-written-array}
read_zarr_array(zarr_array_path = path_to_new_zarr, index = list(6:10, 10, 1))
```

# Appendix

## Session info {.unnumbered}

```{r, session-info, echo = FALSE}
sessionInfo()
```

