#' Print a summary of a Zarr array
#'
#' When reading a Zarr array using [read_zarr_array()] it is necessary to know
#' it's shape and size. `zarr_array_overview()` can be used to get a quick
#' overview of the array shape and contents, based on the .zarray metadata file
#' each array contains.
#'
#' The function currently prints the following information to the R console: 
#'  - array path
#'  - array shape and size
#'  - chunk and size
#'  - the number of chunks
#'  - the datatype of the array
#'  - codec used for data compression (if any)
#'
#' @param zarr_array_path A character vector of length 1.  This provides the
#'   path to a single Zarr array. This can either be on a local file system or
#'   on S3 storage.
#'
#' @return The function invisible returns `TRUE` if successful.  However it is
#'   primarily called for the side effect of printing details of the Zarr array
#'   to the screen.
#'   
#' @examples
#'
#' ## Using a local file provided with the package
#' z1 <- system.file("extdata", "zarr_examples", "row-first",
#'                   "int32.zarr", package = "Rarr")
#'
#' ## read the entire array
#' zarr_array_overview(zarr_array_path = z1)  
#' 
#' ## using a file on S3 storage
#' z2 <- "https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0101A/13457539.zarr/1"
#' zarr_array_overview(z2)
#'
#' @export
zarr_array_overview <- function(zarr_array_path) {
  
  s3_provider <- s3_provider(path = zarr_array_path)
  dot_zarray <- read_array_metadata(path = zarr_array_path, s3_provider = s3_provider)
  
  dt <- parse_datatype(dot_zarray$dtype)
  nchunks <- ceiling(unlist(dot_zarray$shape) / unlist(dot_zarray$chunks))
  
  cat("Path:", normalizePath(zarr_array_path, mustWork = FALSE), "\n")
  cat("Shape:", paste(unlist(dot_zarray$shape), collapse = " x "), "\n")
  cat("Chunk Shape:", paste(unlist(dot_zarray$chunks), collapse = " x "), "\n")
  cat("No. of Chunks: ", prod(nchunks), " (", paste(nchunks, collapse = " x "), ")", "\n", sep = "")
  cat("Data Type: ", dt$base_type, 8 * dt$nbytes, "\n", sep = "")
  cat("Endianness:", dt$endian, "\n")
  if(is.null(dot_zarray$compressor)) {
    cat("Compressor: None\n")
  } else {
    cat("Compressor:", dot_zarray$compressor$id)
  }
  
  invisible(TRUE)
}


#' @import jsonlite
#' @importFrom httr2 url_parse
#' @importFrom stringr str_extract str_remove
#' @importFrom aws.s3 s3read_using
#' 
#' @keywords Internal
read_array_metadata <- function(path, s3_provider = NULL) {
  
  zarray_path <- file.path(path, ".zarray")
  
  if(!is.null(s3_provider)) {
    if(s3_provider == "aws") {
      parsed_url <- url_parse_aws(zarray_path)
      metadata <- s3read_using(FUN = read_json, 
                               object = parsed_url$object, 
                               bucket = parsed_url$bucket, 
                               opts = list(region = parsed_url$region, 
                                           base_url = parsed_url$hostname))
      
    } else {
      parsed_url <- url_parse(zarray_path)
      bucket <- str_extract(parsed_url$path, pattern = "^/([[:alnum:]-]*)") |> 
        str_remove("/")
      object <- str_remove(string = parsed_url$path, pattern = "^/[[:alnum:]-_]*/")
      metadata <- s3read_using(FUN = read_json, 
                   object = object, 
                   bucket = bucket, 
                   opts = list(region = "", base_url = parsed_url$hostname))
    }
  } else {
    metadata <- read_json(file.path(path, ".zarray"))
  }
  
  metadata <- update_fill_value(metadata)
  
  return(metadata)
}

#' Convert special fill values from strings to numbers
#' 
#' Special case fill values (NaN, Inf, -Inf) are encoded as strings in the Zarra
#' metadata.  R will create arrays of type character if these are defined and
#' the chunk isn't present on disk. This function updates the fill value to be
#' R's representation of these special values, so numeric arrays are created.
#'
#' @param metadata A list containing the array metadata.  This should normally
#'   be generated by running `read_json()` on the `.zarray` file.
#'
#' @keywords Internal
update_fill_value <- function(metadata) {
  
  if(metadata$fill_value %in% c("NaN", "Infinity", "-Infinity")) {
    datatype <- parse_datatype(metadata$dtype)
    if(datatype$base_type != "string") {
      metadata$fill_value <- switch(
        metadata$fill_value,
        "NaN" = NaN,
        "Infinity" = Inf,
        "-Infinity" = -Inf
      )
    }
  }
  return(metadata)
  
}

#' @import jsonlite
read_zarr_metadata <- function(zarr_file) {
  
  archive_metadata <- file.path(zarr_file, ".zmetadata")
  if(file.exists(archive_metadata)) {
    metadata <- read_json(file.path(zarr_file, ".zmetadata"))
  } else {
    metadata <- NULL
  }
  return(metadata)
}


parse_datatype <- function(typestr) {
  
  datatype <- list()
  datatype_parts <- strsplit(typestr, "")[[1]]
  
  datatype$endian <- switch(datatype_parts[1],
                            "<" = "little",
                            ">" = "big",
                            "|" = NA)
  
  datatype$base_type <- switch(datatype_parts[2],
                               "b" = "boolean",
                               "i" = "int",
                               "u" = "uint",
                               "f" = "float",
                               "c" = "complex",
                               "m" = "timedelta",
                               "M" = "datetime",
                               "S" = "string",
                               "U" = "Unicode",
                               "v" = "other")
  
  datatype$nbytes <- as.integer(datatype_parts[3])
  
  datatype$is_signed <- ifelse(datatype$base_type != "uint", TRUE, FALSE)
  
  return(datatype)
  
}